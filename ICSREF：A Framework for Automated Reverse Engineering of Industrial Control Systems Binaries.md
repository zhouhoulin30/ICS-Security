# ICSREF: A Framework for Automated Reverse Engineering of Industrial Control Systems Binaries

# ICSREF：一个工业控制系统二进制文件自动逆向工程框架

## 摘要

近年来，随着针对工业环境的真实的威胁的发现，工业控制系统（ICS）的安全性受到了越来越多的关注。尽管如此，但对可编程逻辑控制器（PLC）的ICS二进制文件进行自动化逆向工程的过程仍是一个未解决的问题，主要是因为ICS供应商使用专有编译器。这种自动化可能是一把双刃剑；一方面，它可以加速数字取证调查和事件响应行动，而另一方面，它可以动态生成恶意ICS有效载荷。

在这项工作中，我们提出了一种结构化方法论，该方法论自动化了ICS二进制文件的逆向工程过程，并考虑到了它们独特的特定领域特性。我们应用这种方法论开发了模块化的工业控制系统逆向工程框架（ICSREF），并为用CODESYS编译的二进制文件实例化ICSREF模块，CODESYS是PLCs广泛使用的软件栈和编译器。

为了评估我们的框架，我们通过从公共代码仓库收集真实的PLC二进制文件以及内部开发二进制文件来创建一个样本数据库。

我们的结果显示，ICSREF能够成功处理来自不同行业部门的多样化PLC二进制文件，无论使用的是什么编程语言。此外，我们在商用智能手机上部署了ICSREF，该智能手机编排并发起了针对化学过程测试平台的完全自动化的过程感知攻击。这种动态有效载荷生成的示例展示了ICSREF如何在没有任何先验知识的情况下，使复杂攻击成为可能。

## Ⅰ. 简介

ICS通过可编程逻辑控制器（PLC）控制物理过程。工艺工程师通过开发代码来编程这些控制器，这些代码被编译成控制目标PLC的二进制文件。对于希望保护和希望攻击ICS过程的行为者来说，一个重要目标是自动化逆向工程PLC二进制文件。一方面，这种能力可以在ICS网络攻击后加速行动。数字取证与事件响应（DFIR）团队可以利用自动化逆向工程来理解PLC恶意软件的攻击目的，并及时部署对策。另一方面，ICS恶意软件设计师可以利用相同的能力来实现不需要与指挥控制（C2）中心通信的动态有效载荷，即使是针对处于隔离网络中的目标，也能启用复杂的攻击。

迄今为止，据我们所知，自动化逆向工程ICS PLC二进制文件的问题仍是一个未解决的问题[30]，[26]。ICS二进制文件的逆向工程仍然是一个繁琐的手动过程，由领域专家逆向工程师执行，这些工程师对研究中的系统有着广泛的了解。最近的学术文献关于ICS安全性也强调，自动化逆向工程是一个重要的未解决问题；作者要么对感兴趣的二进制文件做过于简化的假设，要么假定通过其他手段（例如，间谍活动）获取物理过程的信息[14]，[2]，[31]，[15]，[49]。此外，IT世界中逆向工程二进制文件的工具、框架和技术（例如，交互式反汇编器 - IDA Pro）并不直接适用于OT世界[34]。其中一个原因是ICS供应商通常使用专有和/或文档记录不充分的编译器来生成目标PLC的二进制文件；西门子PLC使用SIMATIC STEP 7编程，艾伦·布拉德利PLC使用Studio 5000 Logix Designer，而大多数其他ICS供应商使用CODESYS框架。

识别出方法论方法的差距，以及缺乏专门针对PLC定制的框架和工具，在本文中，我们提出了一种考虑到PLC二进制文件独特特性的方法论，并引入了工业控制系统逆向工程框架（ICSREF）。ICSREF自动化了ICS二进制文件的逆向工程过程，并且可以提供关于系统物理特性的信息，这些信息被控制它的ICS二进制文件捕获，而无需任何系统的先验知识。

PLC二进制文件的自动化逆向工程可以支持广泛的研究。一方面，来自ICSREF分析产生的富含语义的信息可以被用于增强ICS的安全性。一个突出需要快速、自动化逆向工程PLC二进制文件的防御性用例是PLC恶意软件分析。例如，在Stuxnet被发现后，迫切需要对恶意STEP7有效载荷进行逆向工程，以了解其对目标核电站的影响。手动逆向工程过程既费力又耗时，延迟了取证调查。Stuxnet进行了逆向工程，随后为S7 PLC创建了JEB反编译器，该反编译器可以自动化该过程并加快对西门子S7 PLC二进制文件的分析[37]。同样，ICSREF可以用来分析针对CODESYS启用的PLCs的PLC恶意软件，帮助DFIR专业人士快速确定恶意PLC二进制文件的功能和目标。在分析PLC恶意软件时，ICSREF还可以通过对恶意行为者使用的代码进行指纹识别来帮助确定PLC代码的作者归属。同样地，ICSREF的函数和代码片段指纹识别可以帮助合法行为者证明他们的竞争对手侵犯了IP版权。ICSREF的分析还可以在原始源代码不可用的情况下，帮助恢复源代码和二进制代码的重用，这对于遗留PLC尤为重要。

另一方面，ICSREF强调了在ICS环境中采用适当的、经过验证的安全实践的重要性。另一方面，ICSREF强调了在ICS环境中采用适当的、经过验证的安全实践的重要性。例如，自动化逆向工程可以使得动态的过程感知有效载荷生成成为可能，降低了恶意行为者的要求，并允许在不需要先验知识的情况下对隔离系统发起复杂的攻击。

```python
过程感知有效载荷是指在网络攻击中，特别是针对工业控制系统（ICS）或其他复杂系统时，恶意软件或攻击代码能够识别和理解目标系统的运行过程和逻辑。这种类型的有效载荷能够根据系统的实时状态或特定过程参数来调整其行为，使攻击更加精确和有效。

在ICS环境中，过程感知有效载荷特别重要，因为这些系统控制着关键的物理过程，如能源生产、水处理和制造。这些有效载荷通过精确了解目标系统的操作逻辑，可以实施针对性的攻击，从而导致物理损害、生产中断或安全事故，而不仅仅是数据泄露或服务中断。

例如，一个过程感知的恶意软件可能会分析PLC（可编程逻辑控制器）的运行数据，识别出控制特定化学反应的代码段，然后修改参数以使反应失控，引发安全事故。这种攻击方式要求攻击者有深入的目标系统知识，而自动化逆向工程工具（如ICSREF）使得生成这种类型的有效载荷变得更加可行，即使是对于那些对目标系统不够了解的攻击者。
```

  我们的贡献可以总结如下：

- 我们提出了一种针对通用PLC二进制文件的结构化逆向工程方法论，该方法论捕获了它们的复杂性和独特特征。
- 我们开发了ICSREF，一个用于PLC二进制文件的逆向工程框架，它能够==自动分析使用CODESYS平台创建的二进制文件，并完全重建它们的控制流图（CFG）==。
- 我们从公共代码库中收集和整合PLC源代码和二进制文件，为进一步研究创建样本数据库。
- 我们进行了一个端到端的案例研究，关于针对化学过程的动态有效载荷生成和攻击部署。一台配备了ICSREF的商用智能手机自动生成并部署了攻击，无需任何对过程的先验知识。

本文的其余部分组织如下：在第二部分中，我们提供了关于ICS和PLC二进制文件的背景信息，并识别出它们与传统二进制文件相比的独特特性。我们在第三部分提出了一种专门针对PLC二进制文件的结构化逆向工程方法论。在第四部分中，我们介绍了ICSREF框架并展示了其技术细节。第五部分展示了我们验证ICSREF正确性的技术和结果，包括从公共代码仓库收集真实二进制文件并创建数据库，以及我们框架的性能评估。我们在第六部分演示了一个端到端的案例研究，关于通过在商用智能手机上使用ICSREF自动化攻击的构建和部署。我们在第七部分将ICSREF与相关工作进行比较，并在第八部分总结论文。

## Ⅱ. 预备知识

在本节中，我们将提供有关ICS环境的背景信息，并概述PLC二进制文件与传统二进制文件相比的独特特性。

### A. 工业控制系统

ICS是一个广泛的术语，包括用于控制和监控工业过程的各种类型的配置。这些配置包括用于地理分散系统的数据采集与监视控制系统（SCADA）系统、用于具有自主控制器的大型工业过程的分散控制系统（DCS）以及用于小型工业环境的过程控制系统（PCS）。==ICS可以被抽象为一组控制算法，这些算法对通过传感器从物理环境中获得的一系列测量值进行操作。这些控制算法的结果反过来又通过执行器用来调节被控制的物理过程[35]。通过传感器感知环境、计算控制信号并更新执行器上的输出的过程也被称为扫描周期（图1左侧），通常由PLC以连续且实时的方式执行[44]。==PLC是封装在坚固外壳中的实时嵌入式系统，以承受它们被部署到的恶劣工业环境。它们通常包括一个或多个微处理器、易失性和非易失性存储器、模拟和数字I/O子系统以及网络功能[34]。

[![pFc4iIs.png](https://s21.ax1x.com/2024/03/13/pFc4iIs.png)](https://imgse.com/i/pFc4iIs)

### B. PLC程序的软件开发

国际电工委员会（IEC）在IEC 61131中为PLC定义了行业标准。更具体地说，该标准的第三部分，IEC 61131-3，涉及PLC的软件架构和编程，包括编程语言、数据类型、变量属性等[20]。IEC 61131-3描述了以下用于PLC的图形化和文本编程语言：

- 梯形图（LD），图形化
- 结构化文本（ST），文本化
- 功能块图（FBD），图形化
- 顺序功能图（SFC），图形化
- 指令列表（IL），文本化（已弃用）

PLC软件开发过程如图1所示。工艺工程师在工程工作站开发PLC逻辑。工程工作站配备了供应商提供的符合IEC 61131-3的集成开发环境（IDEs）和针对工厂使用的特定PLC型号的编译器。使用上述一个或多个IEC 61131-3语言开发用于控制物理过程的PLC逻辑，然后使用IEC编译器进行编译。==该二进制文件传输到PLC，这一过程在ICS术语中称为程序下载，其中PLC运行时（PLC的操作系统或固件执行的过程）处理二进制文件的加载和执行，强制执行实时要求并启用PLC二进制执行的调试和监控。==在正常操作中，二进制文件加载到PLC的快速、易失性存储中并从其中执行。==为了确保在断电时快速恢复，PLC二进制文件也存储在非易失性存储中，通常伴随着保留/持久变量，以保存有关系统状态的信息。==从那里，PLC二进制文件和系统执行状态可以在PLC启动时自动加载并在程序非控制性停止后恢复执行。

```python
实时性要求指的是PLC程序必须在严格定义的时间内准确完成任务的能力，这对于控制和监视工业过程尤为重要。例如，在自动化生产线上，PLC需要实时响应传感器输入，精确控制机器动作，以保证生产过程的连续性和安全性。

调试和监控功能使工程师能够检查PLC程序的运行状态，识别和修复编程错误，以及优化程序性能。这包括查看程序执行的步骤、监测变量值的变化、停止和重新启动程序等操作。这些功能对于确保PLC程序能够正确执行其控制逻辑至关重要，特别是在复杂或关键的工业应用中。
```

### C. PLC二进制文件与传统二进制文件

分析PLC二进制文件需要理解它们独特的领域特性，这些特性将它们与针对传统工作负载的二进制文件区分开来。在这里，我们强调两者之间的主要区别，并讨论这些区别是如何促进或阻碍分析的。

**执行模型：**除了编程范式的差异之外，传统二进制文件与PLC二进制文件的执行模型也有所不同。非PLC语言及其编译后的二进制文件通常遵循工作单元的顺序执行（例如，C语言的以分号";"分隔语句[25]）。相反，PLC二进制文件的执行模型由扫描周期决定，无限地执行其包含的三个步骤。这可能会阻碍对整个PLC二进制文件的动态分析，由于它们无限执行的性质，需要适当地切割出代码部分进行个别的动态分析。

**I/O操作：**尽管大多数传统二进制文件依赖于I/O操作来获取输入变量并产生相应的输出，但I/O操作对PLC二进制文件的要重要得多。 在PLC二进制文件中，I/O操作是其功能的关键且必要部分，占据了扫描周期的三分之二。PLC被设计为用于与物理世界交互和控制的设备，这是通过PLC I/O的传感器和执行器信号实现的。因此，识别PLC二进制文件如何与这些I/O进行交互和协调读写操作的机制是必要的。

**文件格式：**为主流操作系统（OS）编译的二进制文件通常遵循文档格式，例如Linux的可执行与链接格式（ELF）和Windows的可移植可执行（PE）格式。这些广泛使用的格式由各自操作系统的加载器处理。相反，PLC二进制文件的加载通常由专有加载器（例如，CODESYS运行时[16]）处理，而且PLC二进制文件的文件格式是自定义的且未知的。这阻碍了PLC二进制文件的分析，因为这些自定义的专有格式需要首先被逆向工程，以允许进一步探索。

```python
CODESYS runtime是CODESYS软件平台的一部分，它允许在各种工业自动化设备上运行和执行用CODESYS开发环境编写的应用程序。CODESYS（Controller Development System）是一个开发工业应用程序的集成开发环境（IDE），广泛用于编程和配置可编程逻辑控制器（PLC）。

CODESYS runtime是一个运行时环境，它在目标设备上安装并运行，为用CODESYS开发的应用程序提供了执行的平台。它处理应用程序逻辑的执行、设备的I/O操作、与其他设备的通信以及其他与运行应用程序相关的任务。通过使用CODESYS runtime，开发者可以创建能够跨不同硬件和操作系统运行的自动化应用程序，从而提高了开发的灵活性和可移植性。

简而言之，CODESYS runtime允许将用CODESYS IDE编写的程序部署并在实际的工业环境中执行，使之成为连接开发过程和实际工业控制实现的关键组件。
```

**优化：**由于各种标准规定了实时执行截止日期和保证的可证明执行要求，PLC二进制文件的编译器通常只进行非常保守的优化，如果有的话[21]。相反，不控制关键环境的传统二进制文件通常采用多种积极的编译器优化技术[3]。虽然这可能导致PLC可执行文件更大且效率更低，但它也可以促进逆向工程，因为它们在功能上会更简单。

总的来说，这些差异可以归因于PLC的特定任务性质，以及工业自动化硬件和软件的悠久历史，这些硬件和软件并不总是遵循通用计算机的发展[17]。任何逆向工程工作都应该了解这些与传统二进制文件的偏差。

## Ⅲ. PLC二进制程序的逆向工程方法论

在本节中，我们提出了一种专门为逆向工程PLC二进制文件量身定做的结构化方法。迄今为止，已经有一些针对任意二进制文件的分析方法和技术（例如，函数识别[4]和类型推断[6]）可以被用于PLC二进制分析的个别子任务。然而，据我们所知，一个系统化、结构化的方法论，从头到尾覆盖整个PLC二进制逆向工程过程的，尚不存在。通过我们提出的方法，我们旨在通过确定必要的步骤和所需的结果来弥补这一缺口。

当对PLC二进制文件进行逆向工程时，传统二进制文件与PLC二进制文件之间的相似性和差异性都应该影响可能采取的方法、技术和工具。考虑到它们独特的属性和本质，我们提出了一种结构化方法论，以实现典型的自动化逆向工程任务和目标，包括两个阶段：

1）一个特定于平台的阶段，针对每个平台（例如，STEP7、Studio 5000或CODESYS）执行一次。在此阶段，我们提取出能够描述并适用于该平台生成的所有二进制文件的一般信息。

2）一个自动化二进制分析阶段，针对每个二进制文件执行。在第二阶段，必须自动化地从PLC二进制文件中提取信息，利用特定于平台的结果。

### A. 特定于平台的阶段

这一阶段旨在提取关于平台特定细节的信息。我们将这个阶段分为两个步骤：1）逆向工程和理解使用该平台编译的PLC二进制文件的一般格式，以及2）创建知识数据库，包含可以促进自动化二进制分析的一般信息。图2展示了特定于平台阶段的示意图。通常，这一阶段每个平台只需要一次性成本，并且需要对正在分析的平台进行最小化实例化（即，使用这个平台的PLC设备及其对应的IDE来生成PLC二进制文件）。

[![pFg3oZj.png](https://s21.ax1x.com/2024/03/14/pFg3oZj.png)](https://imgse.com/i/pFg3oZj)

**1）二进制格式逆向工程：**大多数ICS平台在其PLC二进制文件中使用专有的、未记录的二进制格式。因此，第一步包括理解这些格式并提取相关信息。类似于广泛使用的可执行二进制格式，PLC二进制文件可能包含一个或多个头部、代码和数据部分、动态链接代码的符号表等。尽管没有确定的方法可以逆向工程未知文件格式，但是来自嵌入式系统固件逆向工程和文件格式分析等领域的逆向工程技术可以在这一步骤中提供帮助[8]、[41]、[48]、[11]。除了PLC二进制格式的专有特性外，这一步的另一个障碍是PLC二进制的执行模型。由于扫描周期的无限性质，不能对整个PLC二进制进行动态分析，但只能对适当切割出的指令序列进行分析。尽管如此，PLC二进制文件中缺乏优化可能对这一步有利，因为由于编译结果的不变性，可以更容易地进行概括。

一般来说，二进制格式逆向工程步骤的结果应该包括头部内容的信息，子程序如何被界定，子程序及其反汇编列表的提取，符号表和动态链接函数的识别，以及关于代码和数据部分的信息。

**2）知识数据库：**对于第二步，我们认识到需要创建两个包含能够启用和加速逆向工程任务的一般信息的知识数据库。第一个应该包括有关二进制文件中执行的I/O操作的信息，鉴于这些操作对PLC的重要性。这个==I/O信息数据库==应该包括二进制文件如何从物理I/O读取/写入的信息。在常见的内存映射外设情况下，这些I/O外设的相应地址应该被识别并包含在数据库中。

第二个数据库应该包含已知库函数和代码片段的签名。这些可以在任意二进制文件中识别已知的子程序，减少逆向工程师所需的手动工作。这个==已知函数数据库==应该包含有关==标准函数和库==的信息，这些函数和库可以在二进制文件中==静态链接==。与典型的编程范例类似，IEC 61131-3编程人员可以导入和使用库函数/函数块（F/FB）以及他们自己的F/FB。。典型的示例包括处理网络通信的F/FB（例如，MODBUS/SMTP堆栈）、常见控制算法（例如，PID）和计时功能（例如，触发器、计时器）。识别和指纹标记这些函数可以加速给定二进制文件的分析，因为逆向工程师将不必花时间理解已知的函数。商业IDA Pro反汇编器就采用了类似的方法，使用其F.L.I.R.T.技术[18]。相应的知识数据库应该采用一种签名方案，以确保在指纹子程序时低假阳性和假阴性率。

### B. 自动化二进制分析

第二阶段自动化任意二进制文件的逆向工程过程。它假设二进制文件是使用在前一阶段分析过的已知平台开发的。我们确定了执行自动化分析所需的一组三个核心步骤，并提出了促进常见逆向工程任务的补充步骤。图3总结了这一阶段的要求和组成部分。

[![pFgWgDe.png](https://s21.ax1x.com/2024/03/15/pFgWgDe.png)](https://imgse.com/i/pFgWgDe)

第一个核心步骤应该包括利用上一阶段的二进制文件格式信息，将二进制文件解构为其组成部分。在这一步骤中，必须界定并反汇编所有子程序，并识别代码\数据部分和描述动态链接函数的符号表。第二个核心步骤关注通过查找和解析分支的目标来重构尽可能完整和健全的CFG（控制流图），我们使用[39]中恢复的CFG可靠性和完整性的定义。最后，第三个核心步骤应该识别导致I/O操作的指令，并利用知识数据库对已知函数进行指纹识别。

补充步骤可以增强结果分析并允许进一步自动化。例如，一个补充步骤涉及使用动态二进制分析技术和符号执行[39]自动提取传递给函数调用的参数。这个步骤可以被用来提取有关PLC二进制文件控制的物理环境的语义信息，因为这是由二进制文件捕获的。它还可以帮助恢复丢失的源代码，重新设计和重用代码以及知识产权审计[12]，[47]。另一个补充步骤考虑修改二进制文件。这可以实现动态有效负载生成[30]，或基于主机的防御注入[7]。二进制修改还应该考虑任何文件完整性机制，如CRC检查[43]。下一步应该提供直观的结果表示，包括CFG可视化。在ICSREF的实现中，我们实现了所有这些补充步骤，如下节所述。

我们在本节中描述的结构化方法论是通用的，因为它是考虑到PLC二进制文件的独立于供应商的特性而设计的。因此，无论开发平台如何，都可以遵循这种方法来逆向工程PLC二进制文件。

## Ⅳ. ICSREF框架

在本节中，我们介绍了工业控制系统逆向工程框架（ICSREF）的技术细节，这是我们提出的一种新颖的模块化自动逆向工程框架。应用我们提出的方法论，我们实例化了ICSREF模块，这些模块可以对CODESYS编译的二进制文件进行自动化分析。

[![pFgzrGV.png](https://s21.ax1x.com/2024/03/15/pFgzrGV.png)](https://imgse.com/i/pFgzrGV)

CODESYS是一个与硬件无关的IEC 61131平台，用于工业自动化应用。我们关注CODESYS，因为它被广泛使用；超过250家制造商在其产品中采用它，包括拥有大量ICS市场份额的跨国公司[16]。CODESYS设备目录列出了使用CODESYS编程且当前受支持的349种产品或产品系列[1]。实际上，启用CODESYS的设备数量要大得多，因为有几种产品不再出现在目录中，但仍然在部署中。表Ⅰ列出了主流自动化公司使用的软件开发平台，展示了CODESYS的广泛使用。由于涉及自动化的行业分类不同（工厂自动化，运输，能源，流程自动化，楼宇自动化）以及有关这些公司市场份额的已发布数据的稀疏性，我们没有关于CODESYS市场份额的确切数据。然而，根据我们的领域专业知识和与专家的讨论，我们保守估计，全球至少有20%的PLC使用CODESYS。

### A. 特定于平台的阶段：CODESYS

为了满足第一阶段的需求，我们首先通过逆向工程已知的二进制文件来理解CODESYS PLC二进制文件的格式。随后，我们利用我们的研究结果，自动创建包含PLC I/O内存映射和已知库函数签名的两个知识数据库。我们利用WAGO 750-881进行这些研究。750-881使用ARM微处理器，并使用CODESYS v2.3。尽管如此，我们强调此处呈现的结果并不限于针对WAGO PLC的二进制文件，而是适用于任何使用CODESYS编译的二进制文件，无论制造商是谁。

**1）二进制格式逆向工程：**为了理解在CODESYS PLC二进制文件中使用的格式，我们首先开发了一些执行简单任务的程序。为此，我们使用CODESYS IDE，并使用所有可用的IEC 61131-3语言编写程序。我们为WAGO 750-881使用的ARM架构编译程序，获得相应的PLC二进制文件（WAGO CODESYS二进制文件的文件扩展名为PRG）。我们专注于ARM二进制文件，因为在ICS中部署的嵌入式系统中ARM处理器的激增[33]。针对其他架构编译的二进制文件的初步调查表明，我们在本节描述的研究结果代表了CODESYS编译器机制的总体情况，而且进行少量修改就足以将ICSREF扩展到其他硬件架构。随后，我们检查并逆向工程这些内部生成的PRG二进制文件。我们反汇编这些二进制文件，并花费相当多的时间比较它们的反汇编列表，以理解没有文档说明的CODESYS二进制格式和各种编译器约定。图4总结了我们关于二进制格式和代码子程序结构的发现。 

[![pF2Y2a4.png](https://s21.ax1x.com/2024/03/16/pF2Y2a4.png)](https://imgse.com/i/pF2Y2a4)

**头部：**PRG二进制文件的前80个字节构成包含一般信息的头部。表Ⅱ列出了最重要的信息。例如，通过在头部的0x20偏移处的4字节值上加上0x18，可以获得程序的入口点。得到的值是`Memory INIT`子程序的位置。我们注意到，只逆向工程头部的一部分就足以实现自动化分析。

[![pF2Y4R1.png](https://s21.ax1x.com/2024/03/16/pF2Y4R1.png)](https://imgse.com/i/pF2Y4R1)

**子程序分隔符：**我们确定了可以界定二进制文件中包含的子程序的入口和退出指令序列（即子程序序言和尾声）。在子程序的开始处，CODESYS编译的二进制文件使用以下指令：

```assembly
MOV R12, SP
STMFD SP!, {R11, R12, LR}
MOV R11, R12
```

用于退出子程序的指令是：

```assembly
LDMDB R11, {R11, SP, PC}
```

PLC二进制文件中缺乏优化的一个优点是，这些界定符对于所有ARM CODESYS编译的二进制文件都是唯一且通用的。随后，我们对每个子程序进行反汇编，并深入研究其指令以推导其功能。通过这种方法，我们逆向了整个PRG二进制文件格式，如图4所示。

**全局变量和通用子程序的初始化：**第一个子程序（`Global INIT`）从文件头后的0x50偏移处开始。这个子程序设置常量、变量，并初始化在IEC 61131-3程序的`VAR_GLOBAL`部分定义的函数。PLC程序员通常使用这一部分来定义与受控物理环境相关的程序范围内的常量（例如，缩放因子、PID增益、定时常量）。在全局初始化子程序之后，我们观察到每个二进制文件中都存在的三个简短支持子程序（`Sub 1-3`）。它们之后是一个调试器处理子程序（`SYSDEBUG`），它允许从IDE进行广泛的动态调试。

**静态链接库和用户自定义功能块：**调试器处理子程序之后是导入库F/FBs的子程序。每个静态链接的F/FB由两个子程序组成：一个执行其主要功能（$\textnormal{StaticLib}_{i}$），另一个初始化其本地内存（$\textnormal{StaticLib}_{i} ~\textnormal{INIT}$）。用户定义的F/FBs，即直接由PLC程序员开发的代码，以类似方式放置在库F/FBs之后：首先是执行其主要功能的子程序（$\textnormal{FB}_{i}$），紧随其后的是其初始化子程序（$\textnormal{FB}_{i}~\textnormal{INIT}$）。我们还识别出倒数第二个子程序是主函数，一个在CODESYS中名为$\textnormal{PLC\_PRG}$的用户定义FB。这个子程序是必需的，作为扫描周期的起点。

**符号表：**简单的标准函数，如对REAL类型变量的数学运算，在CODESYS二进制文件中是动态链接的。这些函数的信息包含在一个符号表中，该符号表位于最后一个代码子程序之后。符号表包含一系列以空字符终止的字符串标识符，后面跟着两个字节的数据，如下：

```assembly
DCB "real_add", 0
DCW 0x82
DCB "real_sub", 0
DCW 0x83
```

这两个数据字节被运行时用来计算调用相应函数所需的跳转偏移量。

```python
REAL类型变量的数学运算是指在编程和自动化控制环境中，对浮点数（即实数）进行的算术运算。在工业控制系统和编程语言中，特别是遵循IEC 61131-3标准的编程语言（如用于编程可编程逻辑控制器（PLC）的CODESYS），REAL类型被用来表示可以包含小数部分的数值。

这些数学运算包括但不限于：

加法（+）：将两个REAL类型的变量相加。
减法（-）：从一个REAL类型的变量中减去另一个。
乘法（*）：将两个REAL类型的变量相乘。
除法（/）：将一个REAL类型的变量除以另一个。
取反（-）：改变一个REAL类型变量的符号。
绝对值（ABS）：获取一个REAL类型变量的绝对值。
开方（SQRT）：计算一个REAL类型变量的平方根。
对数（LOG、LN）：计算一个REAL类型变量的对数值。
三角函数（SIN、COS、TAN等）：计算角度的正弦、余弦和正切值。
这些运算是进行自动化控制和数据处理的基础，允许开发者实现涉及实数计算的复杂控制逻辑和算法。在PLC和其他工业控制应用中，这些运算非常重要，因为它们可以用来处理传感器数据、执行控制算法、计算物理参数等。
```

**2）CODESYS知识数据库：**理解了文件格式并考虑到PLC二进制文件的独特特性之后，我们继续进行第二步，创建知识数据库。为了实现这一目标，我们识别了PRG二进制文件的I/O操作机制，并构建了用于识别已知函数的指纹。

**I/O数据库：**为了与环境通信，支持CODESYS的PLC设备中的物理I/O模块被映射到PLC内存空间的特定地址。这些在创建新项目时可以在CODESYS v2.3 IDE中看到，如图5所示。例如，==在WAGO 750-881 PLC的情况下，每当二进制文件中的内存加载操作从0x28CFEC00 - 0x28CFF7F8范围内的内存地址读取时，它实际上是在查询一个传感器，而每当一个内存存储操作在0x28CFD800 - 0x28CFE3F8范围内写入时，它更新了一个执行器==。

[![pF20xAK.png](https://s21.ax1x.com/2024/03/16/pF20xAK.png)](https://imgse.com/i/pF20xAK)

从CODESYS IDE手动提取每个目标PLC程序的值是繁琐且不能扩展的。通过检查IDE安装目录，我们发现每种PLC硬件的所有架构选项都包含在目标（TRG）文件中，这些文件位于IDE的安装目录内。这些数据文件不包含可读信息，使我们怀疑它们被编码和/或压缩。事实上，通过进一步研究TRG文件格式并对不同的TRG文件进行比较分析，我们识别出了使用的编码方案。特别是，该方案采用文件内容的2048位块和一个重复使用的2048位固定序列之间的异或（XOR）。我们进一步验证了相同的方案和序列被用于所有TRG文件，不论供应商和目标PLC，即，这项技术适用于非WAGO PLCs。这使我们能够解析TRG文件并以自动化的方式提取PLC模型的I/O内存映射，填充I/O数据库。

**已知函数数据库：**我们利用前一步骤中对PLC二进制格式的了解，为静态链接的库函数创建指纹。我们选择用于唯一标识每个子程序的签名方案，是其操作码助记符连续序列的SHA-256哈希摘要。我们选择操作码并丢弃指令参数，因为参数可能包含可变信息（例如，绝对分支目标，使用不同的寄存器）。正如我们在实验中验证的，操作码序列定义了子程序的功能，即，库子程序的操作码序列对于我们每个库F/FB都是唯一的，并且不受CODESYS提供的最小编译选项的影响。

```assembly
操作码助记符（Opcode Mnemonics）是汇编语言中用来表示指令操作码的简短文本标记或符号。在编程中，每个处理器指令都有一个对应的操作码（Opcode），这是一个用于指示计算机执行特定操作的数字代码。由于操作码通常以二进制或十六进制形式表示，直接使用这些代码对于人类编程者来说并不直观。因此，为了便于理解和记忆，每个操作码都被赋予了一个助记符。

例如，在ARM架构或x86架构的汇编语言中，操作码助记符可以是：

MOV 用于表示移动（Move）操作，将数据从一个地方移动到另一个地方。
ADD 代表加法（Addition）操作，将两个数值相加。
SUB 表示减法（Subtraction）操作，从一个数值中减去另一个数值。
MUL 代表乘法（Multiply）操作，将两个数值相乘。
DIV 表示除法（Divide）操作，将一个数值除以另一个数值。
JMP 跳转（Jump）操作，改变程序的执行流程到另一个位置。
操作码助记符使得汇编语言代码更易于阅读和编写，因为它们提供了一种更接近自然语言的方式来表达计算机指令。在分析和逆向工程软件，特别是理解和识别软件功能的过程中，操作码助记符和它们形成的序列非常重要。
```

我们通过自动化所有必要的操作，高效地为已知函数数据库填充所有已知库F/FBs的签名。我们的自动化数据库填充工作流生成仅包含对一个F/FB调用的源代码，将代码及其需求导入到CODESYS IDE，并编译它以获得相应的PRG二进制文件。我们分析每个二进制文件以提取它包含的F/FB的签名，并将这个签名添加到我们的数据库中。函数指纹及创建已知函数数据库的整个过程在图6中展示。

[![pF20ztO.png](https://s21.ax1x.com/2024/03/16/pF20ztO.png)](https://imgse.com/i/pF20ztO)

总的来说，我们分析并为我们CODESYS IDE实例中可用的212个库中包含的所有1704个F/FBs创建了签名。自动化过程所需的总时间为11小时44分钟。虽然这是一个耗时的步骤，但这是一次性成本。数据库创建完成后，任何给定PRG二进制文件中的子程序指纹识别解析成为数据库的快速查询。在我们的数据库构建过程中，我们没有发现执行不同操作的F/FBs之间存在任何冲突，这证明了使用操作码序列作为标识符的适用性。此外，通过自动化这一过程，我们可以轻松扩展数据库，以包括新库中的F/FBs签名。

### B. 自动化二进制分析：ICSREF

我们将从CODESYS平台特定阶段提取的知识以及自动化二进制分析步骤整合到ICSREF中。ICSREF能够自动逆向工程PRG二进制文件，包含执行方法论部分概述的第二阶段所有步骤的模块。我们为ICSREF制定的设计目标是：

- 准确性：通过将ICSREF应用到PLC二进制文件得到的结果应该是准确的，包括尽可能完全重建CFG（控制流图）。
- 可扩展性：ICSREF的设计和结构应该能够轻松扩展到新的PLC目标、微架构和IEC 61131-3开发平台。
- 可用性：ICSREF的使用应该简单，并为逆向工程师提供直观的界面。

为了实现这些设计目标，我们采用了模块化方法，其中一个核心模块处理第二阶段的核心步骤。补充模块扩展了结果，提供可视化、函数调用参数提取和二进制修改。

**1）核心模块：**该模块通过执行自动化二进制分析的核心步骤，即二进制分解、CFG重建、以及识别I/O操作和已知函数，来处理任意PRG二进制文件。

**包含的组件：**为了解剖PRG二进制文件，核心模块利用前一阶段的PRG二进制格式信息。然后，它扫描二进制文件寻找子程序界定符，并使用它们来切割出所有子程序，并使用`radare2`生成它们的反汇编列表。最后，它提取符号表并识别任何动态链接的函数。

**CFG重建：**对于每一次二进制分析，无论是否自动化，重建其CFG（控制流图）都至关重要。这包括解决每个子程序内部的分支，以及从一个子程序跳转到另一个子程序。一个可能阻碍完整CFG重建的根本挑战是解决间接分支目标的问题[39]。幸运的是，正如我们下面解释的，PRG二进制文件只包含从一个子程序到另一个子程序或到动态链接函数的间接跳转，并且所有这些间接分支目标的位置都完全包含在二进制文件内。本质上，我们可以提取并解决所有间接分支，从而产生完全重建的CFG图。这是受制于ICS平台管理的严格要求和标准的副产品；缺乏优化避免了复杂的控制流操作，可证明的实时截止日期驱动编译器避免运行时解析的间接跳转。

通过观察子程序的内部结构（见图4的右侧），我们确定了用于从一个子程序跳转到另一个子程序或动态链接函数调用的间接跳转指令如下：

```assembly
STR Ri, [SP,#-4]!
STR LR, [SP,#-4]!
LDR Ri, =SUB_OFFSET
LDR Ri, [Ri]
MOV LR, PC
MOV PC, Ri
NOP
LDR LR, [SP],#4
LDR Ri, [SP],#4
```

本质上，所有跳转目标（$\texttt{SUB\_OFFSET}$）都包含在内存中的一个调用表中。在CODESYS二进制文件中，这个调用表可以完全重构。对于动态链接函数目标，我们确定调用表索引值是根据动态库部分中以空字符结尾的字符串后面的两字节数据值计算出来的。具体来说，跳转偏移量是通过将一个函数的空终止字符串标识符的两字节值乘以4，并将这个结果加上8来计算的。对于二进制文件内的子程序目标（例如，静态链接库F/FBs或用户定义的F/FBs），我们确定调用表是在执行最后一个子程序，即$\texttt{Memory INIT}$之后，由CODESYS运行时构建的。首先，它将二进制文件所需的内存空间初始化为零。其次，它计算调用二进制文件中包含的所有子程序所需的索引偏移量，创建相应的调用表。

我们通过利用$\texttt{angr}$框架的动态符号（和混合具体）执行能力来实现从二进制文件中提取子程序目标的调用表[39] [42] [40]。符号执行允许我们执行二进制文件的特定部分（在这个案例中是$\texttt{Memory INIT}$子程序），而不必知道目标系统的整个状态，这使得ICSREF能够扩展到其他平台。一个重要的挑战是，angr的加载器无法处理PRG格式的二进制文件。我们通过手动告知分析引擎目标架构（在本例中为ARM）并在$\texttt{Memory INIT}$子例程的开头为二进制文件设置一个自定义入口点来克服这一挑战。我们还强制引擎在到达子程序的出口点时停止，以避免状态爆炸。然后，我们解析结果符号状态的内存，提取为二进制文件的子程序偏移量分配的所有索引，有效地重建了所需的调用表。通过这些技术，我们可以解决任意PRG二进制文件中的所有分支目标，有效地重建一个100%准确和完整的CFG。

**I/O操作和已知函数匹配：**我们使用I/O操作数据库来识别导致从/向物理I/O读/写的指令。对于这项任务，我们再次使用$\texttt{angr}$执行符号执行。特别地，我们单独执行每个子程序，检测在内存映射I/O范围内的读/写操作。我们对逆向工程的结果进行注释以反映这些操作，帮助逆向工程师识别二进制文件与物理环境交互的位置。为了将二进制文件中的子程序与已知库F/FBs匹配，我们计算每个子程序的签名，并查询已知函数数据库以查找匹配项。每当存在匹配项时，该子程序的名称在ICSREF结果中被修改，以反映其按库定义的功能。

**2）函数调用参数模块：**动态分析中的一个典型逆向工程步骤涉及提取传递给调用位置子程序的参数。这有助于恢复丢失的源代码，提取与PLC物理环境相关的基于语义的信息，并允许过程感知的动态负载的生成。我们通过开发一个模块在ICSREF中实现函数调用参数提取，该模块可以作为提取传递给比例-积分-微分（PID）函数块参数的PoC。CODESYS实用程序库中定义的PID块如图7所示。我们识别到参数被传递到子程序的本地栈上，并使用$\texttt{angr}$重建这个栈。考虑到参数可能是全局变量/常量，我们首先对$\texttt{Global INIT}$子程序进行符号执行，这些值在其中被定义和设置。随后，我们将执行转移到调用者子程序，并执行它，直到我们到达对感兴趣的函数的调用（在本例中为PID）。最后，我们查询本地栈上的结果符号内存值，有效地提取在调用PID函数期间传递给它的参数。虽然我们为PID函数开发了一个参数提取模块，但这个模块可以很容易地扩展到提取任何函数调用的参数，这些函数的参数列表及其数据类型是已知的。

[![pFRPCGR.png](https://s21.ax1x.com/2024/03/18/pFRPCGR.png)](https://imgse.com/i/pFRPCGR)

```python
比例-积分-微分（PID）控制器是一种广泛使用的反馈控制器，它通过计算与所需设定点（或参考值）的偏差相关的控制动作来自动调整过程。PID控制器结合了三种不同类型的控制策略：

比例（Proportional）：控制动作与当前误差成比例。比例控制能够根据误差的大小产生一个相应的控制输出，使系统更快地响应。

积分（Integral）：控制动作与误差累积随时间的积分成比例。积分控制可以消除系统的稳态误差，提高系统的准确性。

微分（Derivative）：控制动作与误差变化率成比例。微分控制有助于预测误差的未来趋势，通过抑制快速变化的误差，提高系统的稳定性。

PID控制器的效果通过三个参数：比例增益（P）、积分增益（I）和微分增益（D）来调节。通过适当的调节这些参数，PID控制器可以适应不同的工作条件和过程要求。

在工业自动化和各种控制系统中，PID控制器常用于维持过程（如温度、压力、流量、速度等）在某个设定值附近。这是因为PID控制器简单、可靠，且能提供良好的控制性能，特别是在过程行为不断变化的场合。
```

**3）二进制修改模块：**对分析中的二进制文件引入修改可以进行大量的研究。为此，我们为ICSREF开发了一个二进制修改模块。该模块允许覆盖PLC二进制文件中任何位置（包括代码和数据内容的位置）的内容，用新的用户指定的值。示例用途包括修补机器码指令，改变分支目标，通过覆盖“死代码”注入可执行代码，以及修改关键函数的调用参数，因为它们是用相应的模块提取的。这个模块也可以用来引入恶意修改，使不那么复杂的参与者能够制作恶意PLC二进制文件。==为了保护关键基础设施的利益，尽管我们会发布所有ICSREF分析模块，但二进制修改模块将不会公开。==

为了确保我们修改后的PLC二进制文件被硬件PLC视为有效，我们还研究了任何使用的文件完整性机制。特别是，CODESYS使用校验和文件（CHK）来确保二进制文件的完整性。因此，为了生成有效的修改后的二进制文件，我们需要逆向工程这个校验和算法。我们通过确定校验和算法是PRG二进制文件中所有字节的加和，并在我们的二进制修改模块中加入CHK文件生成功能来实现这一点。

**4）可视化模块：**我们开发了一个可视化模块，它提供了直观的ICSREF结果表示，满足了我们的可用性设计目标。将这个模块应用于PLC二进制文件后，生成的调用图可视化如图8中所示。该图是使用DOT图描述语言创建的，其中每个子程序和动态链接函数都是一个节点，它们之间的调用是边。我们为边添加了权重，代表从调用者子程序到被调用者的调用次数。为了区分包含在二进制文件中的代码和动态链接的代码，我们为边使用了不同的颜色；对前者我们使用蓝色边，对后者使用红色边。未知节点的命名遵循典型的$\texttt{sub\_<OFFSET>}$约定，而通过已知函数匹配技术识别的节点使用其库定义名称，以协助逆向工程师。对于包含在二进制中的每个节点（即，不是一个动态链接函数），我们还在最终的SVG图像中为每个节点创建了一个超链接，从节点链接到其对应的反汇编列表，以方便遍历。

[![pFRPixx.png](https://s21.ax1x.com/2024/03/18/pFRPixx.png)](https://imgse.com/i/pFRPixx)

考虑到我们的可用性设计目标，我们用Python 2.7开发了所有ICSREF模块，允许它们在跨平台系统上执行。逆向工程师也可以直接通过使用$\texttt{python cmd2}$库创建的终端界面与分析及其结果进行交互。

## Ⅴ. 实验评估

为了从正确性和性能两个方面评估ICSREF，我们进行了广泛的实验。对于我们的实验，我们使用内部PLC二进制文件，也从公共代码仓库中收集了真实的PLC程序和二进制文件。在这一部分，我们将展示我们分析的实验结果和我们创建的示例PLC程序数据库的细节。

### A. 正确性评估

我们通过对给定PLC二进制文件进行ICSREF分析，并将其结果与对应源代码进行交叉检查和验证，来核实CODESYS特定平台阶段和自动化二进制分析阶段的正确性。这种比较允许进行完整的测试，因为产生研究中的二进制文件的源代码本质上是一个“黄金副本”，包含了评估ICSREF结果正确性所需的所有信息。

**1）内部二进制文件：**我们使用为已知函数数据库生成的1704个PRG二进制文件（见第Ⅳ-A2节），对ICSREF的正确性进行初步评估。这些二进制文件是初步测试的绝佳样本，因为我们拥有所有1704个二进制文件的源代码，并且考虑到它们在构建时只包括对一个库F/FB的调用，这些二进制文件具有非常严格的结构。有了这个先验知识，我们用ICSREF分析所有二进制文件，并插入自动检查，将结果CFG与源代码结构已知的预期CFG进行比较。在所有情况下，ICSREF的结果与预期的CFG相匹配，重建了一个100%完整和准确的CFG。这为ICSREF结果的正确性提供了初步验证，尤其是对于基本的PRG二进制文件。

随后，我们使用内部开发的二进制文件，评估ICSREF在对真实程序进行更复杂分析时的结果。我们再次比较并验证ICSREF结果的正确性，对照程序的预期功能和从其源代码中得出的CFG。

我们在这一步骤中使用的一个示例二进制文件是针对WAGO 750-881 PLC的一个IEC 611313 ST程序。该程序控制一个化学过程的小部分，详细描述见第Ⅵ节。它包含对两个PID控制函数的调用，这些函数在固定时间间隔内执行（使用$\texttt{PID\_FIXCYCLE}$）。该程序还使用了一个作为触发器的数字输入，该程序还采用数字输入，该数字输入使用上升沿检测（使用$\texttt{R\_TRIG}$）作为触发器，使用外部信号协调PLC程序执行。由可视化模块生成的ICSREF分析结果图如图8所示。

为了验证ICSREF的结果是否正确，我们将结果与程序的源代码进行逐行比较，以验证它们是否匹配。这里，为了节省篇幅，我们只关注高级子程序及其调用。主要的$\texttt{PLC\_PRG}$子程序调用了$\texttt{PID\_FIXCYCLE}$功能块两次，后者又分别调用了$\texttt{DERIVATIVE}$和$\texttt{INTEGRAL}$函数；注意，每次调用$\texttt{PID\_FIXCYCLE}$都会调用一次$\texttt{DERIVATIVE}$和两次$\texttt{INTEGRAL}$，这一点我们通过检查其对应库文件中$\texttt{PID\_FIXCYCLE}$的源代码得到。$\texttt{PLC\_PRG}$还调用了$\texttt{R\_TRIG}$以检测外部触发信号。$\texttt{Global INIT}$子程序初始化了所有所需的子程序。从主函数及其被调用者进行了几个其他动态链接函数调用；这些要么是由导入的库FBs进行计算时调用的，要么是执行环境值的缩放/格式化，这一点我们通过深入分析开发的源代码以及所有导入的库F/FBs源代码进行了验证。

**2)来自公共代码仓库的二进制文件：**除了内部开发的二进制文件外，我们还从GitHub上的在线公共仓库收集使用CODESYS开发的真实程序和二进制文件。这些程序由不同的作者开发，针对各种PLC设备，并控制不同的、各异的物理环境。这使得它们特别适合测试我们的框架，因为它们的多样性可以严格测试ICSREF的正确性和通用性。

除了评估ICSREF的正确性之外，通过收集和整合PLC程序和二进制文件，我们创建了一个样本数据库。我们的数据库包含各种复杂工业应用的源代码以及相应的二进制文件，通过提供一个多样化的PLC程序仓库，使各种研究成为可能。我们的数据库的一个直接好处是，它提供了基准程序，可以对在源代码级、二进制级或两者之间运行的方法和技术进行全面评估（正如ICSREF所做的那样）。在本文中，我们正是为了这个目的而利用这个数据库。此外，我们的数据库可以与一组常见的基准程序进行比较研究，并为教育目的提供有用和现实的PLC程序源代码，降低PLC编程和工艺工程的入门门槛。

我们使用GitHub高级搜索选项构造特定的搜索查询，以发现包含CODESYS源代码项目文件的公共代码仓库。这并不简单；虽然这些文件包含PLC应用程序的源代码，但它们是非人类可读的文件。因此，GitHub搜索引擎不会对它们进行索引，也无法在它们的内容中执行搜索。==我们通过利用支持CODESYS项目文件（\*.pro）的辅助文件来克服这一限制，以便确定和收集我们的数据库样本。当使用CODESYS开发PLC程序时，IDE会创建几个辅助文件，如编译信息文件、下载/引用文件、初始化和日志文件，以及符号文件。所有这些文件都是非文本文件，除了*.SYM符号文件。符号文件由ASCII字符组成，包含有关项目版本、项目ID、校验和以及项目大小的信息。由于它们被GitHub索引，我们使用这些文件中存在的关键词（例如，“ProjectId”），结合对带有SYM扩展名的文件的搜索，找到包含CODESYS项目的公共代码仓库。==

总的来说，我们使用上面描述的搜索词从GitHub上的55个用户的127个存储库中识别并下载了471个CODESYS项目文件。在这471个项目文件中，有69的仓库中还包含了相应的PRG二进制文件。通过检查项目文件中包含的字符串，我们提取了目标PLC的详细信息，识别了供应商和目标PLC型号。表III展示了下载项目文件的目标PLC设备供应商。从表中我们观察到，大多数程序（68%）是为WAGO PLCs开发的。这可以归因于两个因素。首先，WAGO PLCs在中小型装置中很受欢迎，这些装置也更有可能公开分享其工艺工程程序。中小型装置中很受欢迎，这些装置也更有可能公开分享其工艺工程程序。

[![pFRKcTI.png](https://s21.ax1x.com/2024/03/18/pFRKcTI.png)](https://imgse.com/i/pFRKcTI)

检查下载的项目文件显示，我们收集到的包括所有IEC 61131-3语言的程序，用于跨多个行业的自动化项目，包括能源部门、建筑自动化、汽车应用、工业部署、机器人等。这些程序的多样性增强了我们数据库的功能，既用于评估ICSREF，也可作为其他研究者使用的基准。

为了评估我们框架的正确性，我们打开下载的项目文件，如果我们能够访问它们，则导入它们的库依赖，最后为目标PLC编译它们，获得相应的PRG文件。在这项评估中，我们的努力受到了限制，因为我们只能访问WAGO PLC的CODESYS IDE，这使得我们只能有意义地编译为WAGO PLC开发的程序。另一个限制是，有些程序需要专有库，而这些库并没有与程序源代码一起共享在不失一般性的情况下，出于上述原因，我们专注于为WAGO PLC编译的PRG二进制文件，以及针对WAGO、OWEN、LENZE和BERGHOF PLCs的69个预编译二进制文件。在丢弃那些已损坏、过于简单或非功能性代码片段的无用程序之后，我们用ICSREF分析了266个二进制文件。

遵循与内部二进制文件相同的方法，我们通过将ICSREF的结果与程序预期功能和CFG进行比较来验证其正确性，这些预期功能和CFG基于它们的源代码。由于程序的复杂性、数量众多，以及我们观察到同一用户开发的程序之间的相似性，我们严格地将ICSREF的结果与每个用户的一个程序的源代码进行比较。我们的结果表明，与内部二进制文件类似，ICSREF的结果在所有情况下都与预期的CFG匹配，重构了一个100%完整和准确的CFG。趣的是，在这次分析中，我们观察到某些二进制文件中包含的子程序数量少于相应源代码中的F/FBs数量。我们仔细检查发现，这是基本的编译器优化的结果，编译器去除了程序永远不会调用的代码。

### B. 性能评估

我们为ICSREF设定的一个重要要求是，它应能够处理任意复杂度和大小的PLC二进制文件。为了评估ICSREF的可扩展性和性能，我们测量了我们数据库中266个PLC二进制文件的不同分析步骤所需的时间。

我们通过在一台配备了Intel i7-7500U CPU和16 GB RAM，运行Ubuntu 16.04的机器上执行ICSREF，收集了所有266个二进制文件的时间结果。图9给出了分析不同大小和不同复杂度的二进制文件所需的时间。这些图描绘了执行ICSREF的不同操作所花费的时间与二进制大小的关系。特别是，图表展示了在以下方面所花费的时间：a）在图9a中使用$\texttt{radare2}$反汇编所有二进制子程序，b）在图9b中通过用$\texttt{angr}$符号执行$\texttt{Memory INIT}$子程序来构造调用表，c）在图9c中是所有其他ICSREF操作，d）最后分析一个二进制文件所需的总时间在图9d中。从图中的曲线我们观察到，ICSREF所需的时间主要由执行子程序反汇编和调用表构建的操作占据。以一个平均大小的310 KB二进制文件为例，其总分析时间为58.1秒，其中反汇编需要16.0秒（27.5%），调用表构建需要41.4秒（71.3%），其他操作需要0.7秒（1.2%）。

[![pFRay2d.png](https://s21.ax1x.com/2024/03/18/pFRay2d.png)](https://imgse.com/i/pFRay2d)

对时间测量的进一步分析让我们能够对ICSREF及其组成部分的性能得出结论。从图9a中，我们观察到子程序反汇编时间与二进制文件大小有线性关系。这是意料之中的，因为较大的二进制文件包含更大、更复杂的子程序，其反汇编将需要更多时间。由$\texttt{angr}$符号执行$\texttt{Memory INIT}$子程序所需的时间，如图9b所示，大致恒定，随着二进制文件大小的增加而略微增加。对于分析的266个二进制文件，这一步骤的平均时间为38.26秒，标准偏差为4.15秒。这也是预期的，因为无论二进制文件的大小如何，$\texttt{Memory INIT}$阶段都遵循相同的步骤来初始化内存和构建调用表。轻微的增加归因于更大程序中子程序数量的增加，导致它们的调用表中有更多条目。所有其他操作，如图9c所示，需要整体执行时间的一小部分，并直观地与二进制文件大小有线性关系。整体分析时间也如图9d所示，与二进制文件大小有线性依赖关系，其斜率是其组成操作斜率的综合。

时间结果展示了ICSREF处理大型二进制文件的可扩展能力。根据我们的经验，即使对于包含数百个函数的复杂网络物理系统，PLC二进制文件的大小也不会超过2000 KB（注意，在我们的现实二进制文件数据库中，没有程序大于550 KB）。由于分析成本是线性的，ICSREF处理一个2000 KB的二进制文件将需要不到5分钟。这是可以接受的，因为每个二进制文件的自动化分析只执行一次。

## Ⅵ. 案例研究：自动化攻击制定和部署

如上所述，ICSREF的自动化二进制逆向工程能力使ICS领域的各种新研究成为可能。在本节中，我们将进行端到端的案例研究，在实际场景中应用ICSREF分析。特别是，我们展示了ICSREF的自动化逆向工程能力如何能够为复杂的ICS环境生成动态有效载荷，而无需任何有关物理过程及其控制器的先验信息[30]。

**威胁模型：**我们在案例研究中考虑的威胁模型由两个参与者组成：攻击设计者和攻击部署者。我们假设攻击设计者拥有先进的技术能力，并设计和规划了整个攻击，但没有物理访问目标设施的权限。相反，假设攻击部署者有物理访问权限（例如，是低级别员工），但缺乏开发攻击的技术技能。部署者可以被操纵或强迫部署攻击。遵循这种威胁模型，我们考虑攻击设计者将攻击载体捆绑在一个不起眼的日常设备中，如智能手机，他们可以将其交给攻击部署者。然后，部署者将其引入目标环境，并执行自动化攻击生成和部署。

在我们的案例研究中，我们描述并部署了一个端到端的自动化利用攻击载体，目标是控制环境中真实的ICS流程。我们的目标过程是田纳西伊斯曼（TE）化工过程，使用来自文献[38]的TE模拟模型的修改版本实现。田纳西伊斯曼挑战过程是一个真实的化工过程模拟，作为一个基准过程发布给学术社区[9]。自发布以来，它在多个过程控制和工业控制系统安全研究中被广泛使用[46]，[24]。在我们修改的TE过程版本中，我们结合了真实的物理PLC设备来处理过程的某些控制循环，并与模拟环境通信。具体来说，我们开发了一个硬件在环测试平台，其中WAGO PLC执行模型的18个PID控制器中的两个。图10描述了我们的测试平台实验设置。在WAGO PLC上执行的二进制文件的功能在第Ⅴ-A1节中详细提供。

[![pFRa6xA.png](https://s21.ax1x.com/2024/03/18/pFRa6xA.png)](https://imgse.com/i/pFRa6xA)

为了自动攻击TE过程，我们根据我们的威胁模型在一部商用智能手机上部署ICSREF，并设计了一个简单的“按下按钮”应用程序。智能手机是一个不起眼的设备，我们假设当部署者将其引入目标环境时不会引起任何警报。我们使用的特定智能手机是运行Ubuntu Touch操作系统的LG Google Nexus 5。攻击部署者只需要建立一个有线或无线连接到现场网络，并启动应用程序。借助ICSREF的自动化逆向工程能力，智能手机可以理解PLC二进制文件的结构，推断出控制过程的物理特性，并生成修改后的二进制文件，以无人监督和自主的方式部署有意义且有影响的攻击。

在我们的实验中，我们对手机进行编程，使其自动执行一系列步骤，如图11所示。简而言之，手机在大约90秒内扫描网络中的工业设备，对它们进行指纹识别，并下载它们包含的任何二进制文件。随后，这些二进制文件会自动用ICSREF进行分析，需要额外的250秒。在这一步中，ICSREF识别二进制文件中是否包含任何PID函数，提取它们的参数，并相应地改变它们，生成修改后的二进制文件。最后，修改后的二进制文件被重新上传到PLC，软重置命令迫使PLC执行恶意代码。这最后一步大约需要60秒。总体而言，整个攻击链从开始到结束执行的时间不到5分钟。这证明了在短时间窗口内部署上下文感知的有效载荷而无需协调，并使用计算能力较弱的计算设备（如智能手机）的可行性。

```python
软重置（Soft Reset）指的是通过软件命令或程序逻辑来重新启动设备而不是物理断电重启的过程。与硬重置（Hard Reset）或物理重置（通过物理开关或断电来重启设备）相比，软重置通常不会完全清除设备的内存或存储，而是让设备重新载入操作系统或程序，从而恢复到一个已知的稳定状态。

在工业控制系统（ICS）或可编程逻辑控制器（PLC）的上下文中，软重置可以用来迅速让设备从某种错误状态恢复到正常工作状态，或者在更新配置、加载新的程序代码之后重新启动设备。软重置通常通过发送特定的命令或执行特定的程序功能来实现，这样做可以最小化系统的停机时间，并且可以远程执行，无需直接接触到设备本身。
```

[![pFRas8H.png](https://s21.ax1x.com/2024/03/18/pFRas8H.png)](https://imgse.com/i/pFRas8H)

作为概念验证（PoC），我们指示手机生成有效载荷，引入对上下文有意义的修改。特别是，我们部署了一个操纵PID函数的有效载荷，因为这些控制原语是ICS中最常用的算法之一。==我们的ICSREF模块通过对已知代码片段进行指纹识别，可以识别PID函数，随后，函数调用参数模块可以提取传递给它们调用的数值。==在调用PID函数期间传递的任何参数都可以被操纵（例如，设定点、比例/积分/微分增益、初始值等）。在不失一般性的情况下，==我们选择改变调节工厂反应器压力的PID调用的比例增益（Kp），并将其增加一个相对于其先前编程值（这对手机和攻击者来说是未知的）的小常数值。为了实现这一点，我们使用我们的函数调用参数模块提取当前的Kp值，并生成一个使用ICSREF二进制修改模块修改它的新二进制文件。引入的改变使反应器压力在较低的压力设定点（大约2350 kPa）而不是最优值2800 kPa处稳定。==反应器压力的影响显示在图12中。==由于这一变化不会导致任何测量变量超出范围，因此不会触发任何报警。然而，较低的反应器压力对全厂性能有负面影响，并导致经济损失。==

[![pFRarPe.png](https://s21.ax1x.com/2024/03/18/pFRarPe.png)](https://imgse.com/i/pFRarPe)

我们强调，要想在没有先验知识的情况下自动生成有效载荷，就必须具备像ICSREF这样的自动化逆向工程能力。如果没有这些，则需要关于二进制文件的先验知识或与C2服务器的交互，这两者都使攻击更加困难，成功的可能性也更小。有了ICSREF，可以自主地从PLC二进制文件中提取工厂的操作细节，并且可以在现场重建对工厂及其特性的视图，从而在更少的先决条件下实现更有影响力的攻击。

## Ⅶ. 相关工作

在关于工业系统安全性的众多已发表的作品中，McLaughlin等人[32]、[31]和Zonouz等人[49]的工作与本文介绍的工作更为接近。特别是，[32]为Allen-Bradley PLCs提出了一个受信任的安全验证器（TSV）。TSV使用符号执行和模型检查来验证在PLC上执行的安全关键代码。在这项工作的基础上，[49]采用了类似的技术来确保PLC代码不违反任何安全要求。SABOT自动针对PLC生成有效载荷，通过将PLC控制指令映射到对目标系统的行为规范[31]。所有这些方法都是在指令列表（IL）PLC代码上操作，这是一种类似汇编的IEC 61131-3语言，并不是CPU直接执行的原生机器代码（注意，IL在IEC标准的第三次修订中已被弃用）。相比之下，ICSREF并不假定可以访问源代码的IL版本。相反，ICSREF直接操作原生二进制文件，这始终存在于执行它的PLC上，从而实现更真实的用例。此外，这3种方法都假设完全或部分了解系统的特定信息，而ICSREF不需要任何事先的知识。

PNF Software为S7 PLC开发的专有闭源JEB反编译器执行与ICSREF的逆向工程分析类似的操作，但目标是西门子控制器的二进制文件[37]。它可以反汇编和反编译西门子S7 PLC的MC7程序，其中MC7代码本质上是由西门子PLC上的运行时解释的专有字节码。反汇编器/反编译器是在其作者手动逆向工程Stuxnet有效载荷之后开发的。相比之下，ICSREF针对的是CODESYS PLC的二进制文件，提供了逆向工程其他目标的能力。ICSREF与此相反，是开源的，其模块化设计使其可以轻松扩展到其他架构和格式，包括西门子MC7字节码。

相关工作还包括通用多平台反编译器，如最先进的Hex-Rays反编译器[19]和RetDec[27]。通常，反编译器可以重新创建给定机器代码的更高级别表示，并且对于执行与ICSREF类似的PLC二进制文件分析可能有用。我们测试了Hex-Rays和RetDec反编译器分析我们的PLC二进制文件数据库的能力，两者都没有提供有用的结果。如上所述，这源于IT和OT之间的差异，这阻碍了IT技术直接转移到OT场景[34]。相比之下，我们在开发ICSREF时遵循的结构化方法论意识到了使用的具体内容和约定，使ICSREF能够成功逆向工程同样的二进制文件。

关于ICS分析，在比ICSREF更高的抽象层次上，直接操作IEC 61131-3源代码，文献[45]的工作解析源代码，生成潜在漏洞的列表，并提出相关设计模式来消除它们。针对PLC源代码的攻击，文献[15]的作者引入了“梯形逻辑炸弹”的概念，这是用IEC 61131-3语言编写的PLC恶意软件的实例。在比ICSREF更低的抽象层次上，文献[5]描述了针对PLC的固件修改攻击，以及针对Allen-Bradley PLC的概念验证实验。同样在固件层面，文献[14]提出了HARVEY，这是一个针对PLC的物理感知根植程序，能够在固件层面有意义地操纵控制命令，实现对抗者最优的攻击。在文献[2]中，利用了嵌入式系统中引脚控制操作的实现细节，用于实例化对PLC的隐蔽攻击，并控制它所调节的物理过程。所有这些工作都假设对目标过程有完全或部分的先知知识。与此相反，ICSREF不需要对PLC二进制文件执行的操作或它所调节的物理环境有任何事先的知识。尽管如此，ICSREF可以与这些技术结合使用以增强它们的分析，因为它可以自动提取所需的上下文信息。

虽然ICSREF不是一个反汇编器，而是一个更通用的针对PLC二进制文件量身定制的框架，但我们仍可以大致将它与也支持脚本的更通用的反汇编框架（如IDA Pro）进行比较。我们考虑过将ICSREF开发为IDA Pro的一套插件，但选择了一个开源的独立框架，这样可以公开自由地使用，而不需要IDA许可证。除了其开源性质，ICSREF与IDA的不同之处在于它是一个跨平台框架。ICSREF完全用Python实现，以便于移植性，并且我们在上一节中的案例研究，其中我们将ICSREF部署在商用ARM架构智能手机上，展示了我们选择的跨平台优势。此外，完全控制开发过程以及对依赖和软件库的选择，结合我们为ICSREF设计的模块化，使得轻松交换ICSREF的底层机制和操作变得可能。例如，ICSREF的用户可以轻松地将$\texttt{radare2}$换成另一个反汇编器，或$\texttt{Graphviz}$换成另一种可视化软件。此外，ICSREF的模块化特性允许它以一种健壮的方式处理各个平台供应商的平台修改和更新。采用结构化的方法论来实现我们的框架，使我们能够轻松捕获受支持平台的修改，并用相应的知识更新ICSREF。

## Ⅷ. 总结

在这项工作中，我们提出了一个结构化方法论，以自动化PLC二进制文件的逆向工程过程，考虑到PLC二进制文件固有的独特特性。使用这种方法论，我们开发了ICSREF，我们的模块化自动化ICS逆向工程框架。ICSREF可以自动分析使用CODESYS创建的PLC二进制文件，CODESYS是工业控制系统三大主要软件平台之一。它可以自动化地完全重建任何给定CODESYS二进制文件的CFG，并独立于供应商、PLC模型和IEC 61131-3语言，执行典型的逆向工程任务。为了评估ICSREF的正确性，我们创建了一个包括源代码和二进制文件的PLC程序数据库，这些数据库可以被社区研究并进一步用作基准。ICSREF的自动化能力使得广泛的分析成为可能，如我们在端到端案例研究中展示的动态有效载荷生成。我们未来的工作包括用执行常见逆向工程任务的额外模块丰富ICSREF的能力，并将ICSREF的知识库扩展到额外的平台和硬件架构。

## 致谢

该项目部分由美国海军研究办公室在奖项N00014-15-1-2182下支持，并由纽约大学阿布扎比全球博士奖学金项目支持。

## 资源

ICSREF及二进制样本数据库可从https://github.com/momalab/ICSREF下载。
